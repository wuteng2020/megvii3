#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import json
import os

class HeaderGen:
    _dtypes = None
    _oprs = None
    _fout = None
    _elemwise_modes = None
    _mgb_src_dir = None

    def __init__(self):
        self._dtypes = set()
        self._oprs = set()
        self._elemwise_modes = set()
        self._mgb_src_dir = os.path.realpath(os.path.join(
            os.path.dirname(__file__), os.path.pardir,
            'brain', 'mebrain', 'src'))

    def extend(self, data):
        for i in data['dtypes']:
            self._dtypes.add(i)
        for i in data['opr_types']:
            self._oprs.add(i)
        for i in data['elemwise_modes']:
            self._elemwise_modes.add(i)

    def generate(self, fout):
        self._fout = fout
        self._write_dtype()
        self._write_elemwise_modes()
        self._write_oprs()
        del self._fout

    def _write_oprs(self):
        defs = ['}',  'namespace opr {']
        for i in self._oprs:
            defs.append('class {};'.format(i))
        defs.append('}')
        defs.append('namespace serialization {')
        defs.append("""
            template<class Opr, class Callee>
            struct OprRegistryCaller {
            }; """)
        for i in sorted(self._oprs):
            defs.append("""
                template<class Callee>
                struct OprRegistryCaller<opr::{}, Callee>: public
                    OprRegistryCallerDefaultImpl<Callee> {{
                }}; """.format(i))
        self._write_def('MGB_OPR_REGISTRY_CALLER_SPECIALIZE', defs)

    def _write_elemwise_modes(self):
        mode_list_path = os.path.realpath(os.path.join(
            os.path.dirname(__file__),
            '../brain/megdnn-v3/scripts/generated/elemwise_modes.txt'))
        with open(mode_list_path) as fin:
            mode_list = [i.strip() for i in fin]

        for i in mode_list:
            if i in self._elemwise_modes:
                content = '_cb({})'.format(i)
            else:
                content = ''
            self._write_def(
                '_MEGDNN_ELEMWISE_MODE_ENABLE_IMPL_{}(_cb)'.format(i), content)
        self._write_def('MEGDNN_ELEMWISE_MODE_ENABLE(_mode, _cb)',
                        '_MEGDNN_ELEMWISE_MODE_ENABLE_IMPL_##_mode(_cb)')

    def _write_dtype(self):
        if 'Float16' not in self._dtypes:
            self._write_def('MEGDNN_DISABLE_FLOT16', 1)

    def _write_def(self, name, val):
        if isinstance(val, list):
            val = '\n'.join(val)
        val = str(val).strip().replace('\n', ' \\\n')
        self._fout.write('#define {} {}\n'.format(name, val))


def main():
    parser = argparse.ArgumentParser(
        description='generate header file for reducing binary size by '
        'stripping unused oprs in a particular network; output file would '
        'be written to bin_reduce.h',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        'inputs', nargs='+',
        help='json files generated by megbrain.serialize_comp_graph_to_file() '
        'for the networks')
    args = parser.parse_args()

    gen = HeaderGen()
    for i in args.inputs:
        with open(i) as fin:
            gen.extend(json.loads(fin.read()))

    with open(os.path.join(
            os.path.dirname(__file__), 'bin_reduce.h'), 'w') as fout:
        gen.generate(fout)

if __name__ == '__main__':
    main()
